start: fbody
fbody: stmt* -> fbody

?primary_expr: op
	| "(" expr ")"
	| generic_selection

mem_load: "mem_load_" SIGN_TYPE BIT_WIDTH "(" argument_expr_list ")"

mem_store: "mem_store_" SIGN_TYPE BIT_WIDTH "(" argument_expr_list ")" ";"

pred_write: "WRITE_PRED" "(" (reg_alias | explicit_reg) "," expr ")"

jump: "JUMP" "(" expr ")"

?enumeration_constant: IDENTIFIER

?generic_selection: GENERIC "(" assignment_expr "," generic_assoc_list ")"

?generic_assoc_list: generic_association
	| generic_assoc_list "," generic_association

?generic_association: type_name ":" assignment_expr
	| DEFAULT ":" assignment_expr

?postfix_expr: primary_expr
	| postfix_expr "[" expr "]"
	| postfix_expr "(" ")"
	| mem_load
	| postfix_expr "." IDENTIFIER
	| postfix_expr PTR_OP IDENTIFIER
	| postfix_expr INC_OP
	| postfix_expr DEC_OP
	| "(" type_name ")" "{" initializer_list "}"
	| "(" type_name ")" "{" initializer_list "," "}"

?argument_expr_list: assignment_expr
	| argument_expr_list "," assignment_expr

?unary_expr: postfix_expr
	| INC_OP unary_expr
	| DEC_OP unary_expr
	| UNARY_OPERATOR cast_expr
	| SIZEOF unary_expr
	| SIZEOF "(" type_name ")"
	| ALIGNOF "(" type_name ")"

UNARY_OPERATOR: "&"
	| "*"
	| "+"
	| "-"
	| "~"
	| "!"

?cast_expr: unary_expr
	| "(" type_name ")" cast_expr

?multiplicative_expr: cast_expr
	| multiplicative_expr MUL_OP cast_expr
	| multiplicative_expr DIV_OP cast_expr
	| multiplicative_expr MOD_OP cast_expr

?additive_expr: multiplicative_expr
	| additive_expr ADD_OP multiplicative_expr
	| additive_expr SUB_OP multiplicative_expr

?shift_expr: additive_expr
	| shift_expr LEFT_OP additive_expr
	| shift_expr RIGHT_OP additive_expr

?relational_expr: shift_expr
	| relational_expr LT_OP shift_expr
	| relational_expr GT_OP shift_expr
	| relational_expr LE_OP shift_expr
	| relational_expr GE_OP shift_expr

?equality_expr: relational_expr
	| equality_expr EQ_OP relational_expr
	| equality_expr NE_OP relational_expr

?and_expr: equality_expr
	| and_expr BIT_AND_OP equality_expr

?exclusive_or_expr: and_expr
	| exclusive_or_expr BIT_XOR_OP and_expr

?inclusive_or_expr: exclusive_or_expr
	| inclusive_or_expr BIT_OR_OP exclusive_or_expr

?logical_and_expr: inclusive_or_expr
	| logical_and_expr AND_OP inclusive_or_expr

?logical_or_expr: logical_and_expr
	| logical_or_expr OR_OP logical_and_expr

?conditional_expr: logical_or_expr
	| logical_or_expr "?" expr ":" conditional_expr

?assignment_expr: conditional_expr
	| unary_expr ASSIGN_OP assignment_expr

ASSIGN_OP: "="
	| MUL_ASSIGN
	| DIV_ASSIGN
	| MOD_ASSIGN
	| ADD_ASSIGN
	| SUB_ASSIGN
	| LEFT_ASSIGN
	| RIGHT_ASSIGN
	| AND_ASSIGN
	| XOR_ASSIGN
	| OR_ASSIGN

?expr: assignment_expr
	| expr "," assignment_expr
	| cancel_slot_expr

?constant_expr: conditional_expr

?declaration: declaration_specifiers ";"
	| declaration_specifiers init_declarator_list ";"
	| static_assert_declaration

?declaration_specifiers: storage_class_specifier declaration_specifiers
	| storage_class_specifier
	| type_specifier declaration_specifiers
	| type_specifier
	| type_qualifier declaration_specifiers
	| type_qualifier
	| function_specifier declaration_specifiers
	| function_specifier
	| alignment_specifier declaration_specifiers
	| alignment_specifier

?init_declarator_list: init_declarator
	| init_declarator_list "," init_declarator

?init_declarator: declarator "=" initializer
	| declarator

?storage_class_specifier: TYPEDEF
	| EXTERN
	| STATIC
	| THREAD_LOCAL
	| AUTO
	| REGISTER

?type_specifier: VOID
	| CHAR
	| SHORT
	| INTEGER
	| LONG
	| FLOAT
	| DOUBLE
	| SIGNED
	| UNSIGNED
	| BOOL
	| COMPLEX
	| IMAGINARY
	| atomic_type_specifier
	| struct_or_union_specifier
	| enum_specifier

?struct_or_union_specifier: struct_or_union "{" struct_declaration_list "}"
	| struct_or_union IDENTIFIER "{" struct_declaration_list "}"
	| struct_or_union IDENTIFIER

?struct_or_union: STRUCT
	| UNION

?struct_declaration_list: struct_declaration
	| struct_declaration_list struct_declaration

?struct_declaration: specifier_qualifier_list ";"
	| specifier_qualifier_list struct_declarator_list ";"
	| static_assert_declaration

?specifier_qualifier_list: type_specifier specifier_qualifier_list
	| type_specifier
	| type_qualifier specifier_qualifier_list
	| type_qualifier

?struct_declarator_list: struct_declarator
	| struct_declarator_list "," struct_declarator

?struct_declarator: ":" constant_expr
	| declarator ":" constant_expr
	| declarator

?enum_specifier: ENUM "{" enumerator_list "}"
	| ENUM "{" enumerator_list "," "}"
	| ENUM IDENTIFIER "{" enumerator_list "}"
	| ENUM IDENTIFIER "{" enumerator_list "," "}"
	| ENUM IDENTIFIER

?enumerator_list: enumerator
	| enumerator_list "," enumerator

?enumerator: enumeration_constant "=" constant_expr
	| enumeration_constant

?atomic_type_specifier: ATOMIC "(" type_name ")"

?type_qualifier: CONST
	| RESTRICT
	| VOLATILE
	| ATOMIC

?function_specifier: INLINE
	| NORETURN

?alignment_specifier: ALIGNAS "(" type_name ")"
	| ALIGNAS "(" constant_expr ")"

?declarator: pointer direct_declarator
	| direct_declarator

?direct_declarator: IDENTIFIER
	| "(" declarator ")"
	| direct_declarator "[" "]"
	| direct_declarator "[" "*" "]"
	| direct_declarator "[" STATIC type_qualifier_list assignment_expr "]"
	| direct_declarator "[" STATIC assignment_expr "]"
	| direct_declarator "[" type_qualifier_list "*" "]"
	| direct_declarator "[" type_qualifier_list STATIC assignment_expr "]"
	| direct_declarator "[" type_qualifier_list assignment_expr "]"
	| direct_declarator "[" type_qualifier_list "]"
	| direct_declarator "[" assignment_expr "]"
	| direct_declarator "(" parameter_type_list ")"
	| direct_declarator "(" ")"
	| direct_declarator "(" identifier_list ")"

?pointer: "*" type_qualifier_list pointer
	| "*" type_qualifier_list
	| "*" pointer
	| "*"

?type_qualifier_list: type_qualifier
	| type_qualifier_list type_qualifier


?parameter_type_list: parameter_list "," ELLIPSIS
	| parameter_list

?parameter_list: parameter_declaration
	| parameter_list "," parameter_declaration

?parameter_declaration: declaration_specifiers declarator
	| declaration_specifiers abstract_declarator
	| declaration_specifiers

?identifier_list: IDENTIFIER
	| identifier_list "," IDENTIFIER

?type_name: specifier_qualifier_list abstract_declarator
	| specifier_qualifier_list

?abstract_declarator: pointer direct_abstract_declarator
	| pointer
	| direct_abstract_declarator

?direct_abstract_declarator: "(" abstract_declarator ")"
	| "[" "]"
	| "[" "*" "]"
	| "[" STATIC type_qualifier_list assignment_expr "]"
	| "[" STATIC assignment_expr "]"
	| "[" type_qualifier_list STATIC assignment_expr "]"
	| "[" type_qualifier_list assignment_expr "]"
	| "[" type_qualifier_list "]"
	| "[" assignment_expr "]"
	| direct_abstract_declarator "[" "]"
	| direct_abstract_declarator "[" "*" "]"
	| direct_abstract_declarator "[" STATIC type_qualifier_list assignment_expr "]"
	| direct_abstract_declarator "[" STATIC assignment_expr "]"
	| direct_abstract_declarator "[" type_qualifier_list assignment_expr "]"
	| direct_abstract_declarator "[" type_qualifier_list STATIC assignment_expr "]"
	| direct_abstract_declarator "[" type_qualifier_list "]"
	| direct_abstract_declarator "[" assignment_expr "]"
	| "(" ")"
	| "(" parameter_type_list ")"
	| direct_abstract_declarator "(" ")"
	| direct_abstract_declarator "(" parameter_type_list ")"

?initializer: "{" initializer_list "}"
	| "{" initializer_list "," "}"
	| assignment_expr

?initializer_list: designation initializer
	| initializer
	| initializer_list "," designation initializer
	| initializer_list "," initializer

?designation: designator_list "="

?designator_list: designator
	| designator_list designator

?designator: "[" constant_expr "]"
	| "." IDENTIFIER

?static_assert_declaration: STATIC_ASSERT "(" constant_expr "," STRING_LITERAL ")" ";"

?stmt: labeled_stmt
	| compound_stmt
	| expr_stmt
	| selection_stmt
	| iteration_stmt
	| jump_stmt
	| mem_store
	| pred_write

cancel_slot_expr: "cancel_slot"

?labeled_stmt: IDENTIFIER ":" stmt
	| CASE constant_expr ":" stmt
	| DEFAULT ":" stmt

?compound_stmt: "{" "}"
	| "{"  block_item_list "}"

?block_item_list: block_item
	| block_item_list block_item

?block_item: declaration
	| stmt

?expr_stmt: ";"
	| expr ";"

?selection_stmt: IF "(" expr ")" stmt ELSE stmt
	| IF "(" expr ")" stmt
	| SWITCH "(" expr ")" stmt

?iteration_stmt: WHILE "(" expr ")" stmt
	| DO stmt WHILE "(" expr ")" ";"
	| FOR "(" expr_stmt expr_stmt ")" stmt
	| FOR "(" expr_stmt expr_stmt expr ")" stmt
	| FOR "(" declaration expr_stmt ")" stmt
	| FOR "(" declaration expr_stmt expr ")" stmt

?jump_stmt: jump ";"
    | GOTO IDENTIFIER ";"
	| CONTINUE ";"
	| BREAK ";"
	| RETURN ";"
	| RETURN expr ";"

?translation_unit: external_declaration
	| translation_unit external_declaration

?external_declaration: function_definition
	| declaration

?function_definition: declaration_specifiers declarator declaration_list compound_stmt
	| declaration_specifiers declarator compound_stmt

?declaration_list: declaration
	| declaration_list declaration

?op: reg "V"
    | new_reg "N"
    | imm "iV"
    | explicit_reg
    | reg_alias
    | number
    | identifier

identifier: IDENTIFIER

new_reg: _reg
new_alias: reg_alias "_NEW"
reg: _reg

_reg: REG_TYPE (SRC_REG | DEST_REG | SRC_DEST_REG)
    | REG_TYPE (SRC_REG_PAIR | DEST_REG_PAIR | SRC_DEST_REG_PAIR)

explicit_reg: "R31" | "P0" | "P1" | "P2" | "P3"

reg_alias: "HEX_REG_ALIAS_" /[A-Z0-9]+/

?number: [NUM_SIGN] (HEX_NUMBER | DEC_NUMBER) [INT_POST_TYPE]

imm: IMMEDIATE
// Patterns from:
// https://github.com/quic/qemu/blob/9d66a1fe6b1f83bc27ce78c1d56bece967340052/target/hexagon/hex_common.py#L39
IMMEDIATE: /[rRsSuUmn]/

// Register descriptions:
// https://github.com/quic/qemu/blob/9d66a1fe6b1f83bc27ce78c1d56bece967340052/target/hexagon/hex_common.py#L138
REG_TYPE: /[CNPRMQVO]/
SRC_REG: /[stuvw]/
SRC_REG_PAIR: "ss" | "tt" | "uu" | "vv"
DEST_REG: /[de]/
DEST_REG_PAIR: "dd"
SRC_DEST_REG: /[xyz]/
SRC_DEST_REG_PAIR: "xx" | "yy"

INT_POST_TYPE: "LL" | "ULL"
HEX_NUMBER: /0x[\da-f]*/i
DEC_NUMBER: /0|[1-9][\d_]*/i
NUM_SIGN: /[-+]/i

SIGN_TYPE: /[su]/
BIT_WIDTH: "8" | "16" | "32" | "64"

AUTO: "auto" 
BREAK: "break" 
CASE: "case" 
CHAR: "char" 
CONST: "const" 
CONTINUE: "continue" 
DEFAULT: "default" 
DO: "do" 
DOUBLE: "double" 
ELSE: "else" 
ENUM: "enum" 
EXTERN: "extern" 
FLOAT: "float" 
FOR: "for" 
GOTO: "goto" 
IF: "if" 
INLINE: "inline" 
INTEGER: "int" 
LONG: "long" 
REGISTER: "register" 
RESTRICT: "restrict" 
RETURN: "return" 
SHORT: "short" 
SIGNED: "signed" 
SIZEOF: "sizeof" 
STATIC: "static" 
STRUCT: "struct" 
SWITCH: "switch" 
TYPEDEF: "typedef" 
UNION: "union" 
UNSIGNED: "unsigned" 
VOID: "void" 
VOLATILE: "volatile" 
WHILE: "while" 
ALIGNAS: "_Alignas" 
ALIGNOF: "_Alignof" 
ATOMIC: "_Atomic" 
BOOL: "_Bool" 
COMPLEX: "_Complex" 
GENERIC: "_Generic" 
IMAGINARY: "_Imaginary" 
NORETURN: "_Noreturn" 
STATIC_ASSERT: "_Static_assert" 
THREAD_LOCAL: "_Thread_local" 
FUNC_NAME: "__func__" 
STRING_LITERAL: IDENTIFIER

ELLIPSIS: "..." 
RIGHT_ASSIGN: ">>=" 
LEFT_ASSIGN: "<<=" 
ADD_ASSIGN: "+=" 
SUB_ASSIGN: "-=" 
MUL_ASSIGN: "*=" 
DIV_ASSIGN: "/=" 
MOD_ASSIGN: "%=" 
AND_ASSIGN: "&=" 
XOR_ASSIGN: "^=" 
OR_ASSIGN: "|=" 
RIGHT_OP: ">>" 
LEFT_OP: "<<" 
INC_OP: "++" 
DEC_OP: "--" 
PTR_OP: "->" 
AND_OP: "&&" 
OR_OP: "||" 
LT_OP: "<"
GT_OP: ">"
LE_OP: "<=" 
GE_OP: ">=" 
EQ_OP: "==" 
NE_OP: "!="
MUL_OP: "*"
DIV_OP: "/"
MOD_OP: "%"
ADD_OP: "+"
SUB_OP: "-"
BIT_OR_OP: "|"
BIT_AND_OP: "&"
BIT_XOR_OP: "^"

IDENTIFIER: /[A-Za-z_]+\w*/

%import common.ESCAPED_STRING
%import common.WORD
%import common.INT
%import common.DIGIT
%import common.SIGNED_NUMBER
%import common.WS
%ignore WS
